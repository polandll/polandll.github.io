<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Data Manipulation :: Apache Cassandra Documentation</title>
    <meta name="generator" content="Antora 2.3.1">
    <link rel="stylesheet" href="../../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Apache Cassandra Documentation&nbsp;&nbsp;&nbsp;<img src="../../../../_/img/cassandra_logo.png"></a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Download</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Latest</a>
            <a class="navbar-item" href="#">3.x</a>
            <a class="navbar-item" href="#">3.0</a>
            <a class="navbar-item" href="#">2.1</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Documentation</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Latest</a>
            <a class="navbar-item" href="#">3.x</a>
            <a class="navbar-item" href="#">3.0</a>
            <a class="navbar-item" href="#">2.1</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Developer Mailing List</a>
            <a class="navbar-item" href="#">User Mailing List</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Blog</a>
	</div>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ASCIIDOC_POC" data-version="4.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">ASCIIDOC_POC</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../index.html">Cassandra Documentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../glossary.html">Glossary</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../bugs.html">How to report bugs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../contactus.html">Contact us</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Cassandra</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../architecture/index.html">Architecture</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../architecture/overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../architecture/dynamo.html">Dynamo</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../architecture/storage_engine.html">Storage engine</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../architecture/guarantees.html">Guarantees</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../new/index.html">What&#8217;s new</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../getting_started/index.html">Getting Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../getting_started/installing.html">Installing Cassandra</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../getting_started/configuring.html">Configuring Cassandra</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../getting_started/querying.html">Inserting and querying</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../getting_started/drivers.html">Client drivers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../getting_started/production.html">Production recommendations</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../data_modeling/index.html">Data Modeling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#cql/index.adoc{">CQL</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="changes.html">Changes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="ddl.html">DDL</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="dml.html">DML</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="types.html">Data types</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="operators.html">Operators</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="definitions.html">Definitions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="indexes.html">Secondary indexes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="mvs.html">Materialized views</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="functions.html">Functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="json.html">JSON</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="triggers.html">Triggers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="appendices.html">Appendices</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/index.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operating/index.html">Operating</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../tools/index.html">Tools</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../development/index.html">Development</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../plugins/index.html">Plug-ins</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/index.html">Troubleshooting</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faq/index.html">FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ASCIIDOC_POC</span>
    <span class="version">4.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">ASCIIDOC_POC</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">4.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">ASCIIDOC_POC</a></li>
    <li>Cassandra</li>
    <li>CQL</li>
    <li><a href="dml.html">DML</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/lorina.poland/CLONES/cassandra-examples/rst-to-asciidoc-tests/ASCIIDOC/modules/cassandra/pages/cql/dml.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Data Manipulation</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This section describes the statements supported by CQL to insert,
update, delete and query data.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="select-statement"><a class="anchor" href="#select-statement"></a>SELECT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Querying data from data is done using a <code>SELECT</code> statement:</p>
</div>
<div class="paragraph">
<p>select_statement: SELECT [ JSON | DISTINCT ] (
<span class="title-ref">select_clause</span> | '<em>' ) : FROM <code>table_name</code> : [ WHERE
<code>where_clause</code> ] : [ GROUP BY <code>group_by_clause</code> ] : [ ORDER BY
<code>ordering_clause</code> ] : [ PER PARTITION LIMIT (<code>integer</code> | <code>bind_marker</code>)
] : [ LIMIT (<code>integer</code> | <code>bind_marker</code>) ] : [ ALLOW FILTERING ]
select_clause: <code>selector</code> [ AS <code>identifier</code> ] ( ',' <code>selector</code> [ AS
<code>identifier</code> ] ) selector: <code>column_name</code> : | <code>term</code> : | CAST '('
<code>selector</code> AS <code>cql_type</code> ')' : | <code>function_name</code> '(' [ <code>selector</code> ( ','
<code>selector</code> )</em> ] ')' : | COUNT '(' '<em>' ')' where_clause: <code>relation</code> ( AND
<code>relation</code> )</em> relation: <span class="title-ref">column_name</span> <span class="title-ref">operator</span>
<span class="title-ref">term</span> : '(' <span class="title-ref">column_name</span> ( ','
<span class="title-ref">column_name</span> )* ')' <span class="title-ref">operator</span>
<span class="title-ref">tuple_literal</span> : TOKEN '(' <span class="title-ref">column_name</span> ( ','
<span class="title-ref">column_name</span> )* ')' <span class="title-ref">operator</span>
<span class="title-ref">term</span> operator: '=' | '&lt;' | '&gt;' | '&#8656;' | '&gt;=' | '!=' | IN |
CONTAINS | CONTAINS KEY group_by_clause: <span class="title-ref">column_name</span> ( ','
<span class="title-ref">column_name</span> )* ordering_clause: <span class="title-ref">column_name</span>
[ ASC | DESC ] ( ',' <span class="title-ref">column_name</span> [ ASC | DESC ] )*</p>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT name, occupation FROM users WHERE userid IN (199, 200, 207);
SELECT JSON name, occupation FROM users WHERE userid = 199;
SELECT name AS user_name, occupation AS user_occupation FROM users;

SELECT time, value
FROM events
WHERE event_type = 'myEvent'
  AND time &gt; '2011-02-03'
  AND time &lt;= '2012-01-01'

SELECT COUNT (*) AS user_count FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SELECT</code> statements reads one or more columns for one or more rows
in a table. It returns a result-set of the rows matching the request,
where each row contains the values for the selection corresponding to
the query. Additionally, <code>functions &lt;cql-functions&gt;</code> including
<code>aggregation &lt;aggregate-functions&gt;</code> ones can be applied to the result.</p>
</div>
<div class="paragraph">
<p>A <code>SELECT</code> statement contains at least a
<code>selection clause &lt;selection-clause&gt;</code> and the name of the table on which
the selection is on (note that CQL does <strong>not</strong> joins or sub-queries and
thus a select statement only apply to a single table). In most case, a
select will also have a <code>where clause &lt;where-clause&gt;</code> and it can
optionally have additional clauses to <code>order &lt;ordering-clause&gt;</code> or
<code>limit &lt;limit-clause&gt;</code> the results. Lastly, <code>queries that require
filtering &lt;allow-filtering&gt;</code> can be allowed if the <code>ALLOW FILTERING</code>
flag is provided.</p>
</div>
<div class="sect2">
<h3 id="selection-clause"><a class="anchor" href="#selection-clause"></a>Selection clause</h3>
<div class="paragraph">
<p>The <code>select_clause</code> determines which columns needs to be queried and
returned in the result-set, as well as any transformation to apply to
this result before returning. It consists of a comma-separated list of
<em>selectors</em> or, alternatively, of the wildcard character (<code>*</code>) to select
all the columns defined in the table.</p>
</div>
<div class="sect3">
<h4 id="selectors"><a class="anchor" href="#selectors"></a>Selectors</h4>
<div class="paragraph">
<p>A <code>selector</code> can be one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A column name of the table selected, to retrieve the values for that
column.</p>
</li>
<li>
<p>A term, which is usually used nested inside other selectors like
functions (if a term is selected directly, then the corresponding column
of the result-set will simply have the value of this term for every row
returned).</p>
</li>
<li>
<p>A casting, which allows to convert a nested selector to a (compatible)
type.</p>
</li>
<li>
<p>A function call, where the arguments are selector themselves. See the
section on <code>functions &lt;cql-functions&gt;</code> for more details.</p>
</li>
<li>
<p>The special call <code>COUNT(*)</code> to the <code>COUNT function &lt;count-function&gt;</code>,
which counts all non-null results.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aliases"><a class="anchor" href="#aliases"></a>Aliases</h4>
<div class="paragraph">
<p>Every <em>top-level</em> selector can also be aliased (using <span class="title-ref">AS</span>).
If so, the name of the corresponding column in the result set will be
that of the alias. For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">// Without alias
SELECT intAsBlob(4) FROM t;

//  intAsBlob(4)
// --------------
//  0x00000004

// With alias
SELECT intAsBlob(4) AS four FROM t;

//  four
// ------------
//  0x00000004</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Currently, aliases aren&#8217;t recognized anywhere else in the statement
where they are used (not in the <code>WHERE</code> clause, not in the <code>ORDER BY</code>
clause, &#8230;&#8203;). You must use the orignal column name instead.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="writetime-and-ttl-function"><a class="anchor" href="#writetime-and-ttl-function"></a><code>WRITETIME</code> and <code>TTL</code> function</h4>
<div class="paragraph">
<p>Selection supports two special functions (that aren&#8217;t allowed anywhere
else): <code>WRITETIME</code> and <code>TTL</code>. Both function take only one argument and
that argument <em>must</em> be a column name (so for instance <code>TTL(3)</code> is
invalid).</p>
</div>
<div class="paragraph">
<p>Those functions allow to retrieve meta-information that are stored
internally for each column, namely:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the timestamp of the value of the column for <code>WRITETIME</code>.</p>
</li>
<li>
<p>the remaining time to live (in seconds) for the value of the column if
it set to expire (and <code>null</code> otherwise).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="where-clause"><a class="anchor" href="#where-clause"></a>The <code>WHERE</code> clause</h3>
<div class="paragraph">
<p>The <code>WHERE</code> clause specifies which rows must be queried. It is composed
of relations on the columns that are part of the <code>PRIMARY KEY</code> and/or
have a <a href="#createIndexStmt">secondary index</a> defined on them.</p>
</div>
<div class="paragraph">
<p>Not all relations are allowed in a query. For instance, non-equal
relations (where <code>IN</code> is considered as an equal relation) on a partition
key are not supported (but see the use of the <code>TOKEN</code> method below to do
non-equal queries on the partition key). Moreover, for a given partition
key, the clustering columns induce an ordering of rows and relations on
them is restricted to the relations that allow to select a <strong>contiguous</strong>
(for the ordering) set of rows. For instance, given:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">CREATE TABLE posts (
    userid text,
    blog_title text,
    posted_at timestamp,
    entry_title text,
    content text,
    category int,
    PRIMARY KEY (userid, blog_title, posted_at)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query is allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT entry_title, content FROM posts
 WHERE userid = 'john doe'
   AND blog_title='John''s Blog'
   AND posted_at &gt;= '2012-01-01' AND posted_at &lt; '2012-01-31'</code></pre>
</div>
</div>
<div class="paragraph">
<p>But the following one is not, as it does not select a contiguous set of
rows (and we suppose no secondary indexes are set):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">// Needs a blog_title to be set to select ranges of posted_at
SELECT entry_title, content FROM posts
 WHERE userid = 'john doe'
   AND posted_at &gt;= '2012-01-01' AND posted_at &lt; '2012-01-31'</code></pre>
</div>
</div>
<div class="paragraph">
<p>When specifying relations, the <code>TOKEN</code> function can be used on the
<code>PARTITION KEY</code> column to query. In that case, rows will be selected
based on the token of their <code>PARTITION_KEY</code> rather than on the value.
Note that the token of a key depends on the partitioner in use, and that
in particular the RandomPartitioner won&#8217;t yield a meaningful order. Also
note that ordering partitioners always order token values by bytes (so
even if the partition key is of type int, <code>token(-1) &gt; token(0)</code> in
particular). Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM posts
 WHERE token(userid) &gt; token('tom') AND token(userid) &lt; token('bob')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Moreover, the <code>IN</code> relation is only allowed on the last column of the
partition key and on the last column of the full primary key.</p>
</div>
<div class="paragraph">
<p>It is also possible to “group” <code>CLUSTERING COLUMNS</code> together in a
relation using the tuple notation. For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM posts
 WHERE userid = 'john doe'
   AND (blog_title, posted_at) &gt; ('John''s Blog', '2012-01-01')</code></pre>
</div>
</div>
<div class="paragraph">
<p>will request all rows that sorts after the one having “John&#8217;s Blog” as
<code>blog_tile</code> and '2012-01-01' for <code>posted_at</code> in the clustering order. In
particular, rows having a <code>post_at &#8656; '2012-01-01'</code> will be returned as
long as their <code>blog_title &gt; 'John''s Blog'</code>, which would not be the case
for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM posts
 WHERE userid = 'john doe'
   AND blog_title &gt; 'John''s Blog'
   AND posted_at &gt; '2012-01-01'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The tuple notation may also be used for <code>IN</code> clauses on clustering
columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM posts
 WHERE userid = 'john doe'
   AND (blog_title, posted_at) IN (('John''s Blog', '2012-01-01'), ('Extreme Chess', '2014-06-01'))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CONTAINS</code> operator may only be used on collection columns (lists,
sets, and maps). In the case of maps, <code>CONTAINS</code> applies to the map
values. The <code>CONTAINS KEY</code> operator may only be used on map columns and
applies to the map keys.</p>
</div>
</div>
<div class="sect2">
<h3 id="group-by-clause"><a class="anchor" href="#group-by-clause"></a>Grouping results</h3>
<div class="paragraph">
<p>The <code>GROUP BY</code> option allows to condense into a single row all selected
rows that share the same values for a set of columns.</p>
</div>
<div class="paragraph">
<p>Using the <code>GROUP BY</code> option, it is only possible to group rows at the
partition key level or at a clustering column level. By consequence, the
<code>GROUP BY</code> option only accept as arguments primary key column names in
the primary key order. If a primary key column is restricted by an
equality restriction it is not required to be present in the <code>GROUP BY</code>
clause.</p>
</div>
<div class="paragraph">
<p>Aggregate functions will produce a separate value for each group. If no
<code>GROUP BY</code> clause is specified, aggregates functions will produce a
single value for all the rows.</p>
</div>
<div class="paragraph">
<p>If a column is selected without an aggregate function, in a statement
with a <code>GROUP BY</code>, the first value encounter in each group will be
returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="ordering-clause"><a class="anchor" href="#ordering-clause"></a>Ordering results</h3>
<div class="paragraph">
<p>The <code>ORDER BY</code> clause allows to select the order of the returned
results. It takes as argument a list of column names along with the
order for the column (<code>ASC</code> for ascendant and <code>DESC</code> for descendant,
omitting the order being equivalent to <code>ASC</code>). Currently the possible
orderings are limited by the <code>clustering order &lt;clustering-order&gt;</code>
defined on the table:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the table has been defined without any specific <code>CLUSTERING ORDER</code>,
then then allowed orderings are the order induced by the clustering
columns and the reverse of that one.</p>
</li>
<li>
<p>otherwise, the orderings allowed are the order of the
<code>CLUSTERING ORDER</code> option and the reversed one.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="limit-clause"><a class="anchor" href="#limit-clause"></a>Limiting results</h3>
<div class="paragraph">
<p>The <code>LIMIT</code> option to a <code>SELECT</code> statement limits the number of rows
returned by a query, while the <code>PER PARTITION LIMIT</code> option limits the
number of rows returned for a given partition by the query. Note that
both type of limit can used in the same statement.</p>
</div>
</div>
<div class="sect2">
<h3 id="allow-filtering"><a class="anchor" href="#allow-filtering"></a>Allowing filtering</h3>
<div class="paragraph">
<p>By default, CQL only allows select queries that don&#8217;t involve
“filtering” server side, i.e. queries where we know that all (live)
record read will be returned (maybe partly) in the result set. The
reasoning is that those “non filtering” queries have predictable
performance in the sense that they will execute in a time that is
proportional to the amount of data <strong>returned</strong> by the query (which can be
controlled through <code>LIMIT</code>).</p>
</div>
<div class="paragraph">
<p>The <code>ALLOW FILTERING</code> option allows to explicitly allow (some) queries
that require filtering. Please note that a query using <code>ALLOW FILTERING</code>
may thus have unpredictable performance (for the definition above), i.e.
even a query that selects a handful of records <strong>may</strong> exhibit performance
that depends on the total amount of data stored in the cluster.</p>
</div>
<div class="paragraph">
<p>For instance, considering the following table holding user profiles with
their year of birth (with a secondary index on it) and country of
residence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">CREATE TABLE users (
    username text PRIMARY KEY,
    firstname text,
    lastname text,
    birth_year int,
    country text
)

CREATE INDEX ON users(birth_year);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the following queries are valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM users;
SELECT * FROM users WHERE birth_year = 1981;</code></pre>
</div>
</div>
<div class="paragraph">
<p>because in both case, Cassandra guarantees that these queries
performance will be proportional to the amount of data returned. In
particular, if no users are born in 1981, then the second query
performance will not depend of the number of user profile stored in the
database (not directly at least: due to secondary index implementation
consideration, this query may still depend on the number of node in the
cluster, which indirectly depends on the amount of data stored.
Nevertheless, the number of nodes will always be multiple number of
magnitude lower than the number of user profile stored). Of course, both
query may return very large result set in practice, but the amount of
data returned can always be controlled by adding a <code>LIMIT</code>.</p>
</div>
<div class="paragraph">
<p>However, the following query will be rejected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM users WHERE birth_year = 1981 AND country = 'FR';</code></pre>
</div>
</div>
<div class="paragraph">
<p>because Cassandra cannot guarantee that it won&#8217;t have to scan large
amount of data even if the result to those query is small. Typically, it
will scan all the index entries for users born in 1981 even if only a
handful are actually from France. However, if you “know what you are
doing”, you can force the execution of this query by using
<code>ALLOW FILTERING</code> and so the following query is valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">SELECT * FROM users WHERE birth_year = 1981 AND country = 'FR' ALLOW FILTERING;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="insert-statement"><a class="anchor" href="#insert-statement"></a>INSERT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Inserting data for a row is done using an <code>INSERT</code> statement:</p>
</div>
<div class="paragraph">
<p>INSERT INTO <code>table_name</code> ( <code>names_values</code> | <code>json_clause</code> )
                   : [ IF NOT EXISTS ]
                   : [ USING <code>update_parameter</code> ( AND <code>update_parameter</code> )* ]
   names_values: <code>names</code> VALUES <code>tuple_literal</code>
   json_clause: JSON <code>string</code> [ DEFAULT ( NULL | UNSET ) ]
   names: '(' <code>column_name</code> ( ',' <code>column_name</code> )* ')</p>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">INSERT INTO NerdMovies (movie, director, main_actor, year)
                VALUES ('Serenity', 'Joss Whedon', 'Nathan Fillion', 2005)
      USING TTL 86400;

INSERT INTO NerdMovies JSON '{"movie": "Serenity",
                              "director": "Joss Whedon",
                              "year": 2005}';</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>INSERT</code> statement writes one or more columns for a given row in a
table. Note that since a row is identified by its <code>PRIMARY KEY</code>, at
least the columns composing it must be specified. The list of columns to
insert to must be supplied when using the <code>VALUES</code> syntax. When using
the <code>JSON</code> syntax, they are optional. See the section on
<code>JSON support &lt;cql-json&gt;</code> for more detail.</p>
</div>
<div class="paragraph">
<p>Note that unlike in SQL, <code>INSERT</code> does not check the prior existence of
the row by default: the row is created if none existed before, and
updated otherwise. Furthermore, there is no mean to know which of
creation or update happened.</p>
</div>
<div class="paragraph">
<p>It is however possible to use the <code>IF NOT EXISTS</code> condition to only
insert if the row does not exist prior to the insertion. But please note
that using <code>IF NOT EXISTS</code> will incur a non negligible performance cost
(internally, Paxos will be used) so this should be used sparingly.</p>
</div>
<div class="paragraph">
<p>All updates for an <code>INSERT</code> are applied atomically and in isolation.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>UPDATE &lt;update-parameters&gt;</code> section for
informations on the <code>update_parameter</code>.</p>
</div>
<div class="paragraph">
<p>Also note that <code>INSERT</code> does not support counters, while <code>UPDATE</code> does.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="update-statement"><a class="anchor" href="#update-statement"></a>UPDATE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Updating a row is done using an <code>UPDATE</code> statement:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>UPDATE `table_name`
                     : [ USING `update_parameter` ( AND `update_parameter` )* ]
                  : SET `assignment` ( ',' `assignment` )*
                  : WHERE `where_clause`
                  : [ IF ( EXISTS | `condition` ( AND `condition` )*) ]
  update_parameter: ( TIMESTAMP | TTL ) ( `integer` | `bind_marker` )
  assignment: `simple_selection` '=' `term`
            :| `column_name` '=' `column_name` ( '+' | '-' ) `term`
            :| `column_name` '=' `list_literal` '+' `column_name`
  simple_selection: `column_name`
                  :| `column_name` '[' `term` ']'
                  :| `column_name` '.' `field_name
  condition: `simple_selection` `operator` `term`</pre>
</div>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">UPDATE NerdMovies USING TTL 400
   SET director   = 'Joss Whedon',
       main_actor = 'Nathan Fillion',
       year       = 2005
 WHERE movie = 'Serenity';

UPDATE UserActions
   SET total = total + 2
   WHERE user = B70DE1D0-9908-4AE3-BE34-5573E5B09F14
     AND action = 'click';</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UPDATE</code> statement writes one or more columns for a given row in a
table. The <code>where_clause</code> is used to select the row to update and must
include all columns composing the <code>PRIMARY KEY</code>. Non primary key columns
are then set using the <code>SET</code> keyword.</p>
</div>
<div class="paragraph">
<p>Note that unlike in SQL, <code>UPDATE</code> does not check the prior existence of
the row by default (except through <code>IF</code>, see below): the row is created
if none existed before, and updated otherwise. Furthermore, there are no
means to know whether a creation or update occurred.</p>
</div>
<div class="paragraph">
<p>It is however possible to use the conditions on some columns through
<code>IF</code>, in which case the row will not be updated unless the conditions
are met. But, please note that using <code>IF</code> conditions will incur a
non-negligible performance cost (internally, Paxos will be used) so this
should be used sparingly.</p>
</div>
<div class="paragraph">
<p>In an <code>UPDATE</code> statement, all updates within the same partition key are
applied atomically and in isolation.</p>
</div>
<div class="paragraph">
<p>Regarding the <code>assignment</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>c = c + 3</code> is used to increment/decrement counters. The column name
after the '=' sign <strong>must</strong> be the same than the one before the '=' sign.
Note that increment/decrement is only allowed on counters, and are the
<em>only</em> update operations allowed on counters. See the section on
<code>counters &lt;counters&gt;</code> for details.</p>
</li>
<li>
<p><code>id = id + &lt;some-collection&gt;</code> and <code>id[value1] = value2</code> are for
collections, see the <code>relevant section
&lt;collections&gt;</code> for details.</p>
</li>
<li>
<p><code>id.field = 3</code> is for setting the value of a field on a non-frozen
user-defined types. see the <code>relevant section
&lt;udts&gt;</code> for details.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="update-parameters"><a class="anchor" href="#update-parameters"></a>Update parameters</h3>
<div class="paragraph">
<p>The <code>UPDATE</code>, <code>INSERT</code> (and <code>DELETE</code> and <code>BATCH</code> for the <code>TIMESTAMP</code>)
statements support the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TIMESTAMP</code>: sets the timestamp for the operation. If not specified,
the coordinator will use the current time (in microseconds) at the start
of statement execution as the timestamp. This is usually a suitable
default.</p>
</li>
<li>
<p><code>TTL</code>: specifies an optional Time To Live (in seconds) for the
inserted values. If set, the inserted values are automatically removed
from the database after the specified time. Note that the TTL concerns
the inserted values, not the columns themselves. This means that any
subsequent update of the column will also reset the TTL (to whatever TTL
is specified in that update). By default, values never expire. A TTL of
0 is equivalent to no TTL. If the table has a default_time_to_live, a
TTL of 0 will remove the TTL for the inserted or updated values. A TTL
of <code>null</code> is equivalent to inserting with a TTL of 0.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delete_statement"><a class="anchor" href="#delete_statement"></a>DELETE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Deleting rows or parts of rows uses the <code>DELETE</code> statement:</p>
</div>
<div class="paragraph">
<p>delete_statement: DELETE <span class="[.title-ref">simple_selection</span> ( ','
<span class="title-ref">simple_selection</span> ) ] : FROM <span class="title-ref">table_name</span> : <span class="USING [.title-ref">update_parameter</span> ( AND
<span class="title-ref">update_parameter</span> )* ] : WHERE <span class="title-ref">where_clause</span> :
<span class="IF ( EXISTS | [.title-ref">condition</span> ( AND <span class="title-ref">condition</span>
)*) ]</p>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">DELETE FROM NerdMovies USING TIMESTAMP 1240003134
 WHERE movie = 'Serenity';

DELETE phone FROM Users
 WHERE userid IN (C73DE1D3-AF08-40F3-B124-3FF3E5109F22, B70DE1D0-9908-4AE3-BE34-5573E5B09F14);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DELETE</code> statement deletes columns and rows. If column names are
provided directly after the <code>DELETE</code> keyword, only those columns are
deleted from the row indicated by the <code>WHERE</code> clause. Otherwise, whole
rows are removed.</p>
</div>
<div class="paragraph">
<p>The <code>WHERE</code> clause specifies which rows are to be deleted. Multiple rows
may be deleted with one statement by using an <code>IN</code> operator. A range of
rows may be deleted using an inequality operator (such as <code>&gt;=</code>).</p>
</div>
<div class="paragraph">
<p><code>DELETE</code> supports the <code>TIMESTAMP</code> option with the same semantics as in
<code>updates &lt;update-parameters&gt;</code>.</p>
</div>
<div class="paragraph">
<p>In a <code>DELETE</code> statement, all deletions within the same partition key are
applied atomically and in isolation.</p>
</div>
<div class="paragraph">
<p>A <code>DELETE</code> operation can be conditional through the use of an <code>IF</code>
clause, similar to <code>UPDATE</code> and <code>INSERT</code> statements. However, as with
<code>INSERT</code> and <code>UPDATE</code> statements, this will incur a non-negligible
performance cost (internally, Paxos will be used) and so should be used
sparingly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="batch_statement"><a class="anchor" href="#batch_statement"></a>BATCH</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multiple <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> can be executed in a single
statement by grouping them through a <code>BATCH</code> statement:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>batch_statement: BEGIN [ UNLOGGED | COUNTER ] BATCH
                : [ USING `update_parameter` ( AND `update_parameter` )* ]
                : `modification_statement` ( ';' `modification_statement` )*
                : APPLY BATCH
modification_statement: `insert_statement` | `update_statement` | `delete_statement`</pre>
</div>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cql hljs" data-lang="cql">BEGIN BATCH
   INSERT INTO users (userid, password, name) VALUES ('user2', 'ch@ngem3b', 'second user');
   UPDATE users SET password = 'ps22dhds' WHERE userid = 'user3';
   INSERT INTO users (userid, password) VALUES ('user4', 'ch@ngem3c');
   DELETE name FROM users WHERE userid = 'user1';
APPLY BATCH;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>BATCH</code> statement group multiple modification statements
(insertions/updates and deletions) into a single statement. It serves
several purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It saves network round-trips between the client and the server (and
sometimes between the server coordinator and the replicas) when batching
multiple updates.</p>
</li>
<li>
<p>All updates in a <code>BATCH</code> belonging to a given partition key are
performed in isolation.</p>
</li>
<li>
<p>By default, all operations in the batch are performed as <em>logged</em>, to
ensure all mutations eventually complete (or none will). See the notes
on <code>UNLOGGED batches &lt;unlogged-batches&gt;</code> for more details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BATCH</code> statements may only contain <code>UPDATE</code>, <code>INSERT</code> and <code>DELETE</code>
statements (not other batches for instance).</p>
</li>
<li>
<p>Batches are <em>not</em> a full analogue for SQL transactions.</p>
</li>
<li>
<p>If a timestamp is not specified for each operation, then all
operations will be applied with the same timestamp (either one generated
automatically, or the timestamp provided at the batch level). Due to
Cassandra&#8217;s conflict resolution procedure in the case of
<a href="http://wiki.apache.org/cassandra/FAQ#clocktie">timestamp ties</a>,
operations may be applied in an order that is different from the order
they are listed in the <code>BATCH</code> statement. To force a particular
operation ordering, you must specify per-operation timestamps.</p>
</li>
<li>
<p>A LOGGED batch to a single partition will be converted to an UNLOGGED
batch as an optimization.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="unlogged-batches"><a class="anchor" href="#unlogged-batches"></a><code>UNLOGGED</code> batches</h3>
<div class="paragraph">
<p>By default, Cassandra uses a batch log to ensure all operations in a
batch eventually complete or none will (note however that operations are
only isolated within a single partition).</p>
</div>
<div class="paragraph">
<p>There is a performance penalty for batch atomicity when a batch spans
multiple partitions. If you do not want to incur this penalty, you can
tell Cassandra to skip the batchlog with the <code>UNLOGGED</code> option. If the
<code>UNLOGGED</code> option is used, a failed batch might leave the patch only
partly applied.</p>
</div>
</div>
<div class="sect2">
<h3 id="counter-batches"><a class="anchor" href="#counter-batches"></a><code>COUNTER</code> batches</h3>
<div class="paragraph">
<p>Use the <code>COUNTER</code> option for batched counter updates. Unlike other
updates in Cassandra, counter updates are not idempotent.</p>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
